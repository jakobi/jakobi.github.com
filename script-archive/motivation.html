<HTML>
<HEAD>
<link rel="icon"          href="/favicon.png"/>
<link rel="shortcut icon" href="/favicon.png"/>
<TITLE>Peter's Script-Archive - Motivation - The Unix Philosophy</TITLE>
<style type="text/css"><!--
   .anno { font-size:.8em }
--></style>
<style type="text/css"><!--
   .num { padding-left:1em; text-align:right; nopadding-right:1em}
   .repo{ text-align:center}
   .file{ nopadding-left:1em; font-family:monospace}
.desc{ padding-left:2em}
--></style>
</HEAD>
<BODY>

<p class=anno>
<a href="/">Home</a> | 
<a href="/script-archive/">Script-Archive</a>
</p>

<H1>Peter's Script-Archive - Motivation - The Unix Philosophy</H1>

<hr>

<H2>Philosophy, Ancient Artes and a Modern Tool Chest</H2>

<p>A  small detour. In the Middle Ages, the Arts, Math and  Philosophy
were  considered  pretty similar. Even a millenium later, this  common
root  and the combination of concepts and ideas from these fields make
up  a  very  valuable way of thinking about systems: For  an  elegant,
efficient  problem  solution that won't degenerate immediately into  a
maintenance     nightmare,     you    still    need     to     combine
<B>Arts&amp;Crafts/</B>    (skills    -   sic!),    <B>Philosophy</B>,
<B>Logic&amp;Mathematics</B>,  and  <B>Engineering</B>. Just  consider
the  title of a classic of the field of Informatics: D.E.Knuth's  "Art
of Programming". Or just one keyword: City Architecture.</p>

<p   class=anno>I  hope  you  did  think  of  the   Gang-Of-Four   and
Design-Patterns just now, right :) ?</p>

<p>Back   to  Unix:  The  <B>Unix  tool  chest</B>  is  a  quite  nice
demonstration  of  <i>combining mostly-orthogonal  viewpoints</i>  and
taking that combination as far as possible. And given the rejuvenation
of  Unix  after  a decade of corporate mistreatments (the  Unix  wars)
thanks  to a medicine called Linux, there's still no end in sight  for
development,  while the foundations and basics have been proven  solid
by the test of time. With some interesting offspring like the Internet
and the Web.</p>



<H2>Combining Orthogonal Concepts</H2>

<p>At its core, Unix is just a suitable combination (read: at just the
right  level  of  abstraction) of a set of  basic  (read:  excellently
selected  and  combined) orthogonal concepts. The concepts as well  as
many  of  the ways to combine them have been extended (e.g. NFS),  but
the  core remains unchanged: a thirty year old shell script has pretty
solid  chances  of working unchanged. With a small  difference:  Given
e.g.  network  access  or  process  substitution,  even  that  ancient
unchanged script suddenly gains new features and uses.</p>

<p>Let's just consider two of these concepts: 1. Everything is a file,
2. Pipes. Now you can already easily extend the usage possibilities of
basic  commands. Maybe even add mknod and sockets, if you're tired  of
being  restricted  to a perceived linear-monocausal design. These  two
concepts  already offer a pretty interesting toolkit, don't they?  Way
better  than  requiring  a programmer to pre-imagine the  set  of  all
possible usage scenarios ahead of time...</p>

<p>Now,  add a third slightly more recent concept to the mix and check
the  set  of  usage scenarios again. So just add a  pinch  of  regular
expressions  and stir; and suddenly basic tools allow solving  complex
tasks previously impossible.</p>

<p>Of  course, customizing these basics is part of the charm of  Unix,
and  thus you'll find a part of my tool chest below, including scripts
for  adapting  text  to  pipe  processing,  or  scripts  that  provide
extensions to regular expression filtering.</p>



<H2>Fast Forward to the Present</H2>

<p>That's  obsolete  stuff just deals with ancient  pre-UNICODE  ASCII
text,  you object. Aren't pipes and commandlines unusable, given  XML,
you ask.</p>

<p>Even  with XML, suitably modified grep, diff and sort commands  are
quite  helpful  in pipes. Just consider XPATH. Just  structuring  text
doesn't  affect  the usability of Unix core concepts at all  -  simply
replace  one  command or another with a more suitable  domain-specific
version,  and  the  time-honed command patterns still  allow  avoiding
tedious  interactive  changes.  And if you want to start or  end  your
workflow in a graphical application, Unix offers those as well.</p>

<p><i>When  working  with the proper abstraction, "things"  don't  really
change that much at all...</i></p>



<H2>Further Reading</H2>

<p>The  first one offers more on the concepts of Unix, the second  one
offers  the  real  meat of the implementation details,  albeit  a  bit
kernel-centric. The slightly heretic "Unix Toolbox" from Kernighan and
Pike  offers a complementaries programmer's tool smith perspective  to
the  first  book. If you haven't read it yet, also  check  Stevenson's
Essay "In the Beginning was the Command Line".</p>

<ul>
   <li>Mike Gancarz, Linux and the Unix Philosophy, Butterworth Heinemann, 2003.
   <li>Marshall Kirk McKusick, The Design and Implementation of the FreeBSD Operating System, AW, 2004.
</ul>

<hr>
<p class=anno>
<a href="/">Home</a> | 
<a href="/script-archive/">Script-Archive</a><p>
<p class=anno>jakobi(at)acm.org, 2009-07 - 2009-08-20</p>
</p>

</BODY>
</HTML>
