<HTML>
<HEAD>
<link rel="icon"          href="/favicon.png"/>
<link rel="shortcut icon" href="/favicon.png"/>
<TITLE>Peter's Homepage - Suggested Tools - A Selection</TITLE>
<style type="text/css"><!--
   .anno { font-size:.8em }
--></style>
<style type="text/css"><!--
   .num { padding-left:1em; text-align:right; nopadding-right:1em}
   .repo{ text-align:center}
   .file{ nopadding-left:1em; font-family:monospace}
.desc{ padding-left:2em}
--></style>
</HEAD>
<BODY>

<p class=anno>
<a href="/">Home</a> | 
<a href="/script-archive/">Script-Archive</a>
</p>

<H1>Peter's Homepage - Suggested Tools - A Selection</H1>

<hr>

<H2>Etymology: Tags Is Derived From TagLs</H2>

<p>[taggl:s]</p>

<p>"speaking names" or<BR>
<a href="http://en.wikipedia.org/wiki/Tag">en.wikipedia.org/wiki/Tag</A> or<BR>
comp/lang/perl/authors/wall,larry/perl.script.process.zap:regex-based-kill</p>

<p>Why  try to store meta information / tags in extra data bases?  Why
modify  file  formats  and  store  meta  information  with  the  file,
requiring  an  extra open or an extra data base? The most  often  used
tags can far simpler be used to make up the file name. Use the primary
hierarchic  relationship for the directory tree, then add a command to
find matching files using arbitrary tag combinations.</p>

<p>A  trivial  find  | grep go a long way when using  the  above  idea
(those  pesky Unix concepts, you remember?). Two ways to improve  this
are  1.  doing  find ahead of time (trivial), 2. getting  rid  of  the
notion of order usually implied by the arguments to grep.</p>

<p>Some                       Larry-Wall-esque                      <a href="http://www.google.com/search?as_q=TIMTOWTDI&hl=en&num=50">TIMTOWTDI
(google  it :)!)</a> to allow more flexibility in the search arguments
doesn't hurt either. A bit of classical logic might just be the ticket
to deal with point two - and if we extend regexes beyond perl's native
capabilities  while  still  being lazy and true to Perl, so  much  the
better: Behold <B>tagls</B>.</p>

<p><i>If  you  are  using tags as part of filenames  (or  just  'speaking
filenames'),  then you may also be interested in tagls, which  handles
searching  in  filelists  with  word boundaries  for  'tags',  synonym
expansion,   boolean  expressions  over  lists  of  tags  or   regular
expressions;  both  against  the  file name or  maybe  also  a  file's
content.   The   output  can  be  unsorted  /  sorted  /   sorted   by
relevance.</i></p>

<p><B>tagls</B>   and  <B>taglsc</B>  are  an  experiment   of   using
file-system  based tags with scripts and the command line. IMHO  quite
successful, very useful, and without relying on a fulltext index.</p>

<p  class=anno>If you just remembered Hans Reiser's ideas on semantics
and  filesystems:  his papers offer indeed interesting usage ideas  on
tags, some of which are adaptable to tagls.</p>



<H3>Major Commands</H3>
<ul>
   <li><B>tagls</B> is a specialized grep implementing boolean expressions over
         word (tags), word lists (taglists), regular expressions and perl scraps,
         enforcing word boundary surrounding tags, allowing for synonyms and
         stemming. It greps a filelist for suitable matching files and optionally
         can also grep inside candidate matches. Results can be highlighted or
         ordered by relevance. Dependencies: expansyn (see cli.perl.grep).
   <li><b>taglsc</b> is a wrapper adding document collections to tagls, by
         allowing the user to associate filelists with collectionnames, and
         then invoking tagls with a suitable filelist as input.
         taglsgrep finally is a wrapper to reconfigure tagls to behave
         as a grep against stdin.
<ul>



</ul></ul><hr>
<p class=anno>
<a href="/">Home</a> | 
<a href="/script-archive/">Script-Archive</a><p>
<p class=anno>jakobi(at)acm.org, 2009-07 - 2009-08-20</p>
</p>

</BODY>
</HTML>
